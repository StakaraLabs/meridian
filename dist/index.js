"use strict";require("reflect-metadata");var e=require("crypto"),t=require("pg"),n=require("uuid"),r=require("fs"),o=require("path"),a=require("dotenv");function i(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var s=i(r),c=i(o),l=i(a);const u=new WeakMap,f=new WeakMap,d=new WeakMap;function m(e){return e.replace(/([A-Z])/g,"_$1").toLowerCase()}let y;function E(e){if(!e||!Array.isArray(e))throw new Error("Vector must be an array of numbers");return`[${e.join(",")}]`}function p(e,t){return e&&Array.isArray(e)?e.length!==t?(console.warn(`Expected embedding dimension of ${t}, but got ${e.length}. Padding or truncating.`),e.length>t?e.slice(0,t):[...e,...Array(t-e.length).fill(0)]):e:(console.warn(`Invalid vector: ${e}`),Array(t).fill(0))}function g(e,t){const n=Reflect.getMetadata("vector_columns",t);if(n){Reflect.getMetadata("columns",t);for(const[t,r]of Object.entries(n)){const n=e[t];if(!n||!Array.isArray(n))continue;const o=p(n,r);e[t]=o}}}function b(e,t){const n={},r=w(t);for(const[t,o]of Object.entries(r)){const r=o.name.toLowerCase();void 0!==e[r]&&(n[t]=e[r])}return n}function w(e){const t=Reflect.getMetadata("columns",e)||{};let n=Object.getPrototypeOf(e);for(;n&&n.name;){const e=Reflect.getMetadata("columns",n);e&&Object.assign(t,e),n=Object.getPrototypeOf(n)}return t}function h(e){return["all","analyse","analyze","and","any","array","as","asc","asymmetric","authorization","binary","both","case","cast","check","collate","column","constraint","create","cross","current_catalog","current_date","current_role","current_schema","current_time","current_timestamp","current_user","default","deferrable","desc","distinct","do","else","end","except","false","fetch","for","foreign","freeze","from","full","grant","group","having","ilike","in","initially","inner","intersect","into","is","isnull","join","lateral","leading","left","like","limit","localtime","localtimestamp","natural","not","notnull","null","offset","on","only","or","order","outer","overlaps","placing","primary","references","returning","right","select","session_user","similar","some","symmetric","table","tablesample","then","to","trailing","true","union","unique","user","using","variadic","verbose","when","where","window","with"].includes(e.toLowerCase())||/[^a-zA-Z0-9_]/.test(e)||/^[0-9]/.test(e)?`"${e}"`:e}function A(e){return`'${e.replace(/'/g,"''")}'`}function $(e){return"string"==typeof e&&/^[a-zA-Z0-9_]+\(.*\)$/.test(e)}async function _(){const e=[],t=c.join(process.cwd(),"db","entities");try{const n=s.readdirSync(t,{withFileTypes:!0});for(const r of n)if(!r.isDirectory()&&(r.name.endsWith(".ts")||r.name.endsWith(".js")))try{const n=c.join(t,r.name),o=await import(n);for(const t of Object.keys(o)){const n=o[t];"function"==typeof n&&Reflect.hasMetadata("table:name",n)&&e.push(n)}}catch(e){console.warn(`Error loading entity file ${r.name}:`,e)}}catch(e){console.warn("Error reading entities directory:",e)}return e}async function R(e){const t={},n=await e.query("\n    SELECT table_name\n    FROM information_schema.tables\n    WHERE table_schema = 'public'\n    AND table_type = 'BASE TABLE'\n  ");for(const r of n.rows){const n=r.table_name;t[n]={columns:[],primaryKey:[],foreignKeys:[],indexes:[]};const o=await e.query("\n      SELECT \n        column_name, \n        data_type, \n        is_nullable, \n        column_default\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n      AND table_name = $1\n    ",[n]);t[n].columns=o.rows;const a=await e.query("\n      SELECT a.attname\n      FROM pg_index i\n      JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)\n      WHERE i.indrelid = $1::regclass\n      AND i.indisprimary\n    ",[n]);t[n].primaryKey=a.rows.map((e=>e.attname));const i=await e.query("\n      SELECT\n        kcu.column_name,\n        ccu.table_name AS foreign_table_name,\n        ccu.column_name AS foreign_column_name\n      FROM information_schema.table_constraints AS tc\n      JOIN information_schema.key_column_usage AS kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      JOIN information_schema.constraint_column_usage AS ccu\n        ON ccu.constraint_name = tc.constraint_name\n        AND ccu.table_schema = tc.table_schema\n      WHERE tc.constraint_type = 'FOREIGN KEY'\n      AND tc.table_name = $1\n    ",[n]);t[n].foreignKeys=i.rows;const s=await e.query("\n      SELECT\n        kcu.column_name\n      FROM information_schema.table_constraints AS tc\n      JOIN information_schema.key_column_usage AS kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      WHERE tc.constraint_type = 'UNIQUE'\n      AND tc.table_name = $1\n    ",[n]);for(const e of s.rows){const r=t[n].columns.find((t=>t.column_name===e.column_name));r&&(r.is_unique=!0)}const c=await e.query("\n      SELECT\n        i.relname AS index_name,\n        array_agg(a.attname) AS column_names,\n        ix.indisunique AS is_unique\n      FROM pg_class t\n      JOIN pg_index ix ON t.oid = ix.indrelid\n      JOIN pg_class i ON i.oid = ix.indexrelid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      WHERE t.relkind = 'r'\n      AND t.relname = $1\n      AND i.relname NOT IN (\n        SELECT constraint_name\n        FROM information_schema.table_constraints\n        WHERE table_name = $1\n        AND constraint_type IN ('PRIMARY KEY', 'UNIQUE')\n      )\n      GROUP BY i.relname, ix.indisunique\n    ",[n]);t[n].indexes=c.rows}return t}function N(e,t=!0){const n=Reflect.getMetadata("table:name",e),r=O(e),o=Reflect.getMetadata("foreign_keys",e)||{},a=Reflect.getMetadata("vector_columns",e)||{};let i=`CREATE TABLE ${h(n)} (\n`;const s=[],c=[];for(const[e,t]of Object.entries(r)){const n=t,r=n.name;if(n.isVector)continue;let o=`  ${h(r)} ${n.type}`;if(n.primary&&c.push(r),n.nullable||(o+=" NOT NULL"),n.unique&&(o+=" UNIQUE"),n.default){const t=n.default();if("jsonb"===n.type&&t.startsWith("ARRAY["))if("promptTypes"===e)o+=' DEFAULT \'["reflection", "questions", "encouragement"]\'::jsonb';else if("preferredTags"===e||"excludedTags"===e)o+=" DEFAULT '[]'::jsonb";else try{const e=t.substring(6,t.length-1);o+=` DEFAULT '["${e.split(",").map((e=>{const t=e.replace(/^'|'$/g,"").trim();return JSON.stringify(t).replace(/^"|"$/g,"")})).join('", "')}"]'::jsonb`}catch(e){console.error("Error parsing JSONB default value:",e),o+=" DEFAULT '[]'::jsonb"}else if("jsonb"===n.type)try{"string"==typeof t?t.endsWith("::jsonb")?o+=` DEFAULT '${t.replace(/::jsonb$/,"")}'::jsonb`:t.startsWith("{")||t.startsWith("[")?o+=` DEFAULT '${t}'::jsonb`:o+=` DEFAULT '${JSON.stringify(t)}'::jsonb`:o+=` DEFAULT '${JSON.stringify(t)}'::jsonb`}catch(e){console.error("Error parsing JSONB default value:",e),o+=" DEFAULT '{}'::jsonb"}else $(t)?o+=` DEFAULT ${t}`:o+=` DEFAULT ${A(t)}`}s.push(o)}if(c.length>0){const e=`  PRIMARY KEY (${c.map(h).join(", ")})`;s.push(e)}if(t)for(const[e,t]of Object.entries(o)){const o=t,a=r[e];if(!a)throw new Error(`Property ${e} is not decorated with @Column`);const i=a.name,c=`  CONSTRAINT ${h(`fk_${n}_${i}`)} FOREIGN KEY (${h(i)}) REFERENCES ${h(o.tableName)}(${h(o.columnName)})`;s.push(c)}i+=s.join(",\n"),i+="\n);\n";for(const[e,t]of Object.entries(a)){const o=r[e];if(!o)throw new Error(`Property ${e} is not decorated with @Column`);const a=o.name;i+=`ALTER TABLE ${h(n)} ADD COLUMN ${h(a)} vector(${t});\n`}return i}function O(e){const t={};let n=e;for(;n&&n.prototype;){const e=Reflect.getMetadata("columns",n)||{};for(const[n,r]of Object.entries(e))t[n]||(t[n]=r);n=Object.getPrototypeOf(n)}return t}function T(e,t){const n=Reflect.getMetadata("table:name",e),r=O(e),o=Reflect.getMetadata("foreign_keys",e)||{},a=Reflect.getMetadata("vector_columns",e)||{};let i="";for(const[e,o]of Object.entries(r)){const e=o,r=e.name;if(e.isVector)continue;const a=t.columns.find((e=>e.column_name===r));if(a){const t=[];e.nullable||"YES"!==a.is_nullable?e.nullable&&"NO"===a.is_nullable&&t.push(`ALTER COLUMN ${h(r)} DROP NOT NULL`):t.push(`ALTER COLUMN ${h(r)} SET NOT NULL`),e.type.toLowerCase()!==a.data_type.toLowerCase()&&t.push(`ALTER COLUMN ${h(r)} TYPE ${e.type} USING ${h(r)}::${e.type}`),t.length>0&&(i+=`ALTER TABLE ${h(n)} ${t.join(", ")};\n`)}else{let t=`${h(r)} ${e.type}`;if(e.nullable||(t+=" NOT NULL"),e.unique&&(t+=" UNIQUE"),e.default){const n=e.default();$(n)?t+=` DEFAULT ${n}`:t+=` DEFAULT ${A(n)}`}i+=`ALTER TABLE ${h(n)} ADD COLUMN ${t};\n`}}for(const[e,a]of Object.entries(o)){const o=a,s=r[e];if(!s)throw new Error(`Property ${e} is not decorated with @Column`);const c=s.name;t.foreignKeys.find((e=>e.column_name===c&&e.foreign_table_name===o.tableName&&e.foreign_column_name===o.columnName))||(i+=`ALTER TABLE ${h(n)} ADD CONSTRAINT ${h(`fk_${n}_${c}`)} FOREIGN KEY (${h(c)}) REFERENCES ${h(o.tableName)}(${h(o.columnName)});\n`)}for(const[e,o]of Object.entries(a)){const a=r[e];if(!a)throw new Error(`Property ${e} is not decorated with @Column`);const s=a.name;t.columns.find((e=>e.column_name===s))||(i+=`ALTER TABLE ${h(n)} ADD COLUMN ${h(s)} vector(${o});\n`)}return i}function L(e,t){const n=Reflect.getMetadata("table:name",e),r=O(e),o=Reflect.getMetadata("foreign_keys",e)||{};let a="";for(const[e,i]of Object.entries(o)){const o=i,s=r[e];if(!s)throw new Error(`Property ${e} is not decorated with @Column`);const c=s.name,l=`fk_${n}_${c}`,u=t[n];u&&u.foreignKeys&&u.foreignKeys.some((e=>e.column_name===c&&e.foreign_table_name===o.tableName&&e.foreign_column_name===o.columnName))||(a+=`ALTER TABLE ${h(n)} ADD CONSTRAINT ${h(l)} FOREIGN KEY (${h(c)}) REFERENCES ${h(o.tableName)}(${h(o.columnName)}) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;\n`)}return a}function S(e,t){let n="";n+="CREATE EXTENSION IF NOT EXISTS vector;\n\n",n+="-- First pass: Create all tables without foreign keys\n";for(const r of e){const e=Reflect.getMetadata("table:name",r);if(t[e]){const o=T(r,t[e]);o&&(n+=`-- Altering table ${e}\n${o}\n`)}else n+=`-- Creating table ${e}\n${N(r,!1)}\n`}n+="\n-- Second pass: Add foreign key constraints\n";for(const r of e){const e=Reflect.getMetadata("table:name",r),o=Reflect.getMetadata("foreign_keys",r)||{};Object.keys(o).length>0&&(n+=`-- Adding foreign keys to ${e}\n${L(r,t)}\n`)}return n}try{require("ts-node").register({project:"tsconfig.node.json",transpileOnly:!0,compilerOptions:{module:"CommonJS"}})}catch(e){console.log("ts-node not available, assuming TypeScript is already compiled")}async function C(e,n=!1,r){let o=!1,a="";try{if(!e){if(!process.env.DATABASE_URL)throw new Error("DATABASE_URL environment variable is not set");e=new t.Pool({connectionString:process.env.DATABASE_URL}),o=!0}const i=await e.connect();try{n||await i.query("BEGIN"),n?console.log("Vector extension would be installed (dry run)"):await async function(e){try{await e.query("CREATE EXTENSION IF NOT EXISTS vector;"),console.log("Vector extension is installed or already exists.")}catch(e){throw console.error("Error ensuring vector extension:",e),e}}(e),r||(r=await _()),console.log(`Loaded ${r.length} entity classes`);const t=await R(e);console.log(`Retrieved current schema with ${Object.keys(t).length} tables`),a=S(r,t),"CREATE EXTENSION IF NOT EXISTS vector;"===a.trim()?console.log("No schema changes needed, database is up to date"):n?(console.log("DRY RUN: The following SQL would be executed:"),console.log(a),console.log("No changes were made to the database (dry run)")):(console.log("Executing migration SQL:"),console.log(a),await i.query(a),console.log("Migration completed")),n||await i.query("COMMIT")}catch(e){throw n||await i.query("ROLLBACK"),console.error("Migration failed:",e),e}finally{i.release()}}finally{o&&e&&await e.end()}return a}l.config(),require.main===module&&C().catch((e=>{console.error("Unhandled error during migration:",e),process.exit(1)})),exports.Column=function(e={}){return function(t,n){let r,o;"string"==typeof n?(r=n,o=t.constructor):(r=n.name,o=n.constructor);let a=u.get(o);a||(a={},u.set(o,a));let i=e.type;if(!i){const e=function(e,t){const n=Reflect.getMetadata("design:type",e,t);if(!n)return"text";switch(n.name){case"String":default:return"text";case"Number":return"double precision";case"Boolean":return"boolean";case"Date":return"timestamp with time zone";case"Array":case"Object":return"jsonb"}}(t,r);if("jsonb"===e){const n=function(e,t){try{const n=(new e.constructor)[t];if(null==n)return t.toLowerCase().includes("date")||t.toLowerCase().includes("time")?"timestamp with time zone":t.toLowerCase().includes("price")||t.toLowerCase().includes("amount")||t.toLowerCase().includes("number")?"double precision":t.toLowerCase().includes("is")||t.toLowerCase().includes("has")||t.toLowerCase().includes("enable")||t.toLowerCase().includes("disable")?"boolean":"text";if("string"==typeof n)return"text";if("number"==typeof n)return"double precision";if("boolean"==typeof n)return"boolean";if(n instanceof Date)return"timestamp with time zone";if(Array.isArray(n))return"jsonb";if("object"==typeof n)return"jsonb"}catch(e){return null}return null}(t,r);i=n||e}else i=e}a[r]={name:e.name||m(r),primary:e.primary||!1,nullable:e.nullable||!1,unique:e.unique||!1,type:i,default:e.default},Reflect.defineMetadata("columns",a,o)}},exports.ForeignKey=function(e,t){return function(n,r){let o,a;"string"==typeof r?(o=r,a=n.constructor):(o=r.name,a=r.constructor);let i=f.get(a);i||(i={},f.set(a,i)),i[o]={tableName:e,columnName:t},Reflect.defineMetadata("foreign_keys",i,a)}},exports.Table=function(e){return function(t,n){return void 0===n?(r=t,Reflect.defineMetadata("table:name",e.name,r),u.has(r)||u.set(r,{}),f.has(r)||f.set(r,{}),d.has(r)||d.set(r,{}),Reflect.defineMetadata("columns",u.get(r),r),Reflect.defineMetadata("foreign_keys",f.get(r),r),Reflect.defineMetadata("vector_columns",d.get(r),r),r):function(t){const n=t;return Reflect.defineMetadata("table:name",e.name,n),u.has(n)||u.set(n,{}),f.has(n)||f.set(n,{}),d.has(n)||d.set(n,{}),Reflect.defineMetadata("columns",u.get(n),n),Reflect.defineMetadata("foreign_keys",f.get(n),n),Reflect.defineMetadata("vector_columns",d.get(n),n),t}(t);var r}},exports.VectorColumn=function(e){return function(t,n){let r,o;"string"==typeof n?(r=n,o=t.constructor):(r=n.name,o=n.constructor);let a=u.get(o);a||(a={},u.set(o,a)),a[r]={name:m(r),isVector:!0},Reflect.defineMetadata("columns",a,o);let i=d.get(o);i||(i={},d.set(o,i)),i[r]=e,Reflect.defineMetadata("vector_columns",i,o)}},exports.deleteBy=async function(e,t,n=y){const r=Reflect.getMetadata("table:name",e),o=w(e),a=[],i=[];let s=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=o[e];if(!t)throw new Error(`Property ${e} is not decorated with @Column`);const r=t.name;a.push(`${r} = $${s}`),i.push(n),s++}if(0===a.length)return 0;const c=`\n    DELETE FROM ${r}\n    WHERE ${a.join(" AND ")}\n  `;return(await n.query(c,i)).rowCount||0},exports.ensureVectorDimensions=p,exports.escapeSqlString=A,exports.findBy=async function(e,t,n=y){const r=Reflect.getMetadata("table:name",e),o=w(e),a=[],i=[];let s=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=o[e];if(!t)throw new Error(`Property ${e} is not decorated with @Column`);const r=t.name;a.push(`${r} = $${s}`),i.push(n),s++}if(0===a.length)return null;const c=`\n    SELECT * FROM ${r}\n    WHERE ${a.join(" AND ")}\n    LIMIT 1\n  `,l=await n.query(c,i);if(0===l.rows.length)return null;const u=new e;return Object.assign(u,b(l.rows[0],e)),u},exports.findSimilarEntries=async function(e,n=10,r=.5,o=y){const a=E(p(e,1536));let i=null,s=!1;try{o instanceof t.Pool?(i=await o.connect(),s=!0):i=o;return(await i.query("\n      SELECT \n        entry_id, \n        1 - (embedding <=> $1) as similarity\n      FROM \n        entry_embedding\n      WHERE \n        1 - (embedding <=> $1) > $2\n      ORDER BY \n        similarity DESC\n      LIMIT $3\n      ",[a,r,n])).rows.map((e=>({entryId:e.entry_id,similarity:e.similarity})))}catch(e){return console.error("Error finding similar entries:",e),[]}finally{s&&i&&i.release()}},exports.formatVector=E,exports.generateAlterTableSQL=T,exports.generateMigrationSQL=S,exports.generateTableSQL=N,exports.getCurrentSchema=R,exports.inferType=function(e,t){const n=Reflect.getMetadata("design:type",e,t);if(!n)return"text";switch(n.name){case"String":default:return"text";case"Number":return"double precision";case"Boolean":return"boolean";case"Date":return"timestamp with time zone";case"Array":case"Object":return"jsonb"}},exports.inferTypeFromValue=function(e,t){try{const n=(new e.constructor)[t];if(null==n)return t.toLowerCase().includes("date")||t.toLowerCase().includes("time")?"timestamp with time zone":t.toLowerCase().includes("price")||t.toLowerCase().includes("amount")||t.toLowerCase().includes("number")?"double precision":t.toLowerCase().includes("is")||t.toLowerCase().includes("has")||t.toLowerCase().includes("enable")||t.toLowerCase().includes("disable")?"boolean":"text";if("string"==typeof n)return"text";if("number"==typeof n)return"double precision";if("boolean"==typeof n)return"boolean";if(n instanceof Date)return"timestamp with time zone";if(Array.isArray(n))return"jsonb";if("object"==typeof n)return"jsonb"}catch(e){return null}return null},exports.isSqlFunction=$,exports.listAll=async function(e,t={},n=y){const r=Reflect.getMetadata("table:name",e),o=w(e),a=[],i=[];let s=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=o[e];if(!t)throw new Error(`Property ${e} is not decorated with @Column`);const r=t.name;a.push(`${r} = $${s}`),i.push(n),s++}let c=`SELECT * FROM ${r}`;return a.length>0&&(c+=` WHERE ${a.join(" AND ")}`),(await n.query(c,i)).rows.map((t=>{const n=new e;return Object.assign(n,b(t,e)),n}))},exports.loadEntityClasses=_,exports.pool=y,exports.processVectorEmbeddings=g,exports.query=async function(e,t={},n=y){const{query:r,values:o}=function(e,t){const n=[],r={};let o=e.replace(/:([\w\d_]+)/g,((e,o)=>{if(void 0===t[o])throw new Error(`Missing parameter: ${o}`);return void 0===r[o]&&(r[o]=n.length+1,n.push(t[o])),`$${r[o]}`}));return{query:o,values:n}}(e,t);return(await n.query(r,o)).rows},exports.quoteIdentifier=h,exports.runMigration=C,exports.save=async function(t,n=y){const r=t.constructor,o=Reflect.getMetadata("table:name",r),a=w(r);if(g(t,r),!t.id){t.id=e.randomUUID(),t.createdAt=new Date,t.updatedAt=new Date;const i=[],s=[],c=[];let l=1;for(const[e,n]of Object.entries(a)){const r=t[e];if(void 0!==r){const e=n.name;i.push(e),s.push(`$${l}`),n.isVector&&Array.isArray(r)?c.push(E(r)):c.push(r),l++}}const u=`\n      INSERT INTO ${o} (${i.join(", ")})\n      VALUES (${s.join(", ")})\n      RETURNING *\n    `,f=await n.query(u,c);Object.assign(t,b(f.rows[0],r))}else{t.updatedAt=new Date;const e=[],i=[];let s=1;for(const[n,r]of Object.entries(a)){const o=t[n];if(void 0!==o&&"id"!==n&&"createdAt"!==n&&"updatedAt"!==n&&"deletedAt"!==n){const t=r.name;e.push(`${t} = $${s}`),r.isVector&&Array.isArray(o)?i.push(E(o)):i.push(o),s++}}e.push(`updated_at = $${s}`),i.push(t.updatedAt),s++,i.push(t.id);const c=`\n      UPDATE ${o}\n      SET ${e.join(", ")}\n      WHERE id = $${s}\n      RETURNING *\n    `,l=await n.query(c,i);Object.assign(t,b(l.rows[0],r))}return t},exports.storeEmbedding=async function(e,r,o=y){const a=p(r,1536),i=E(a);let s=null,c=!1;try{o instanceof t.Pool?(s=await o.connect(),c=!0):s=o;if(0===(await s.query("SELECT 1 FROM entry WHERE id = $1",[e])).rowCount)throw new Error(`Entry with ID ${e} does not exist`);const r=await s.query("SELECT id FROM entry_embedding WHERE entry_id = $1",[e]);if(r.rowCount&&r.rowCount>0)return await s.query("UPDATE entry_embedding SET embedding = $1, updated_at = NOW() WHERE entry_id = $2",[i,e]),{id:r.rows[0].id,entryId:e,embedding:a};return{id:(await s.query("INSERT INTO entry_embedding (id, entry_id, embedding, created_at, updated_at) VALUES ($1, $2, $3, NOW(), NOW()) RETURNING id",[n.v4(),e,i])).rows[0].id,entryId:e,embedding:a}}catch(e){throw console.error("Error storing embedding:",e),e}finally{c&&s&&s.release()}},exports.withSavepoint=async function(e,t,n){try{await n.query(`SAVEPOINT ${e}`);const r=await t();return await n.query(`RELEASE SAVEPOINT ${e}`),r}catch(t){throw await n.query(`ROLLBACK TO SAVEPOINT ${e}`),t}},exports.withTransaction=async function(e,t){const n=!t,r=t||await y.connect();try{await r.query("BEGIN");const t=await e(r);return await r.query("COMMIT"),t}catch(e){throw await r.query("ROLLBACK"),e}finally{n&&r.release()}};
//# sourceMappingURL=index.js.map
