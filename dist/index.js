"use strict";require("reflect-metadata");var e=require("crypto"),t=require("pg"),n=require("uuid"),o=require("fs"),r=require("path"),a=require("dotenv");function s(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var o=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,o.get?o:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var i=s(o),c=s(r),l=s(a);const u=new WeakMap,f=new WeakMap,d=new WeakMap;const m=new t.Pool({connectionString:process.env.DATABASE_URL});function y(e){if(!e||!Array.isArray(e))throw new Error("Vector must be an array of numbers");return`[${e.join(",")}]`}function E(e,t){return e&&Array.isArray(e)?e.length!==t?(console.warn(`Expected embedding dimension of ${t}, but got ${e.length}. Padding or truncating.`),e.length>t?e.slice(0,t):[...e,...Array(t-e.length).fill(0)]):e:(console.warn(`Invalid vector: ${e}`),Array(t).fill(0))}function p(e,t){const n=Reflect.getMetadata("vector_columns",t);if(n){Reflect.getMetadata("columns",t);for(const[t,o]of Object.entries(n)){const n=e[t];if(!n||!Array.isArray(n))continue;const r=E(n,o);e[t]=r}}}function g(e,t){const n={},o=b(t);for(const[t,r]of Object.entries(o)){const o=(r.name||t).toLowerCase();void 0!==e[o]&&(n[t]=e[o])}return n}function b(e){const t=Reflect.getMetadata("columns",e)||{};let n=Object.getPrototypeOf(e);for(;n&&n.name;){const e=Reflect.getMetadata("columns",n);e&&Object.assign({},e,t),n=Object.getPrototypeOf(n)}return t}function A(e){return["all","analyse","analyze","and","any","array","as","asc","asymmetric","authorization","binary","both","case","cast","check","collate","column","constraint","create","cross","current_catalog","current_date","current_role","current_schema","current_time","current_timestamp","current_user","default","deferrable","desc","distinct","do","else","end","except","false","fetch","for","foreign","freeze","from","full","grant","group","having","ilike","in","initially","inner","intersect","into","is","isnull","join","lateral","leading","left","like","limit","localtime","localtimestamp","natural","not","notnull","null","offset","on","only","or","order","outer","overlaps","placing","primary","references","returning","right","select","session_user","similar","some","symmetric","table","tablesample","then","to","trailing","true","union","unique","user","using","variadic","verbose","when","where","window","with"].includes(e.toLowerCase())||/[^a-zA-Z0-9_]/.test(e)||/^[0-9]/.test(e)?`"${e}"`:e}function w(e){return`'${e.replace(/'/g,"''")}'`}function _(e){return"string"==typeof e&&/^[a-zA-Z0-9_]+\(.*\)$/.test(e)}async function h(){const e=[],t=c.join(process.cwd(),"db","entities");try{const n=i.readdirSync(t,{withFileTypes:!0});for(const o of n)if(!o.isDirectory()&&(o.name.endsWith(".ts")||o.name.endsWith(".js")))try{const n=c.join(t,o.name),r=await import(n);for(const t of Object.keys(r)){const n=r[t];"function"==typeof n&&Reflect.hasMetadata("table:name",n)&&e.push(n)}}catch(e){console.warn(`Error loading entity file ${o.name}:`,e)}}catch(e){console.warn("Error reading entities directory:",e)}return e}async function $(e){const t={},n=await e.query("\n    SELECT table_name\n    FROM information_schema.tables\n    WHERE table_schema = 'public'\n    AND table_type = 'BASE TABLE'\n  ");for(const o of n.rows){const n=o.table_name;t[n]={columns:[],primaryKey:[],foreignKeys:[],indexes:[]};const r=await e.query("\n      SELECT \n        column_name, \n        data_type, \n        is_nullable, \n        column_default\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n      AND table_name = $1\n    ",[n]);t[n].columns=r.rows;const a=await e.query("\n      SELECT a.attname\n      FROM pg_index i\n      JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)\n      WHERE i.indrelid = $1::regclass\n      AND i.indisprimary\n    ",[n]);t[n].primaryKey=a.rows.map((e=>e.attname));const s=await e.query("\n      SELECT\n        kcu.column_name,\n        ccu.table_name AS foreign_table_name,\n        ccu.column_name AS foreign_column_name\n      FROM information_schema.table_constraints AS tc\n      JOIN information_schema.key_column_usage AS kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      JOIN information_schema.constraint_column_usage AS ccu\n        ON ccu.constraint_name = tc.constraint_name\n        AND ccu.table_schema = tc.table_schema\n      WHERE tc.constraint_type = 'FOREIGN KEY'\n      AND tc.table_name = $1\n    ",[n]);t[n].foreignKeys=s.rows;const i=await e.query("\n      SELECT\n        kcu.column_name\n      FROM information_schema.table_constraints AS tc\n      JOIN information_schema.key_column_usage AS kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      WHERE tc.constraint_type = 'UNIQUE'\n      AND tc.table_name = $1\n    ",[n]);for(const e of i.rows){const o=t[n].columns.find((t=>t.column_name===e.column_name));o&&(o.is_unique=!0)}const c=await e.query("\n      SELECT\n        i.relname AS index_name,\n        array_agg(a.attname) AS column_names,\n        ix.indisunique AS is_unique\n      FROM pg_class t\n      JOIN pg_index ix ON t.oid = ix.indrelid\n      JOIN pg_class i ON i.oid = ix.indexrelid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      WHERE t.relkind = 'r'\n      AND t.relname = $1\n      AND i.relname NOT IN (\n        SELECT constraint_name\n        FROM information_schema.table_constraints\n        WHERE table_name = $1\n        AND constraint_type IN ('PRIMARY KEY', 'UNIQUE')\n      )\n      GROUP BY i.relname, ix.indisunique\n    ",[n]);t[n].indexes=c.rows}return t}function N(e,t=!0){const n=Reflect.getMetadata("table:name",e),o=R(e),r=Reflect.getMetadata("foreign_keys",e)||{},a=Reflect.getMetadata("vector_columns",e)||{};let s=`CREATE TABLE ${A(n)} (\n`;const i=[],c=[];for(const[e,t]of Object.entries(o)){const n=t,o=n.name;if(n.isVector)continue;let r=`  ${A(o)} ${n.type}`;if(n.primary&&c.push(o),n.nullable||(r+=" NOT NULL"),n.unique&&(r+=" UNIQUE"),n.default){const t=n.default();if("jsonb"===n.type&&t.startsWith("ARRAY["))if("promptTypes"===e)r+=' DEFAULT \'["reflection", "questions", "encouragement"]\'::jsonb';else if("preferredTags"===e||"excludedTags"===e)r+=" DEFAULT '[]'::jsonb";else try{const e=t.substring(6,t.length-1);r+=` DEFAULT '["${e.split(",").map((e=>{const t=e.replace(/^'|'$/g,"").trim();return JSON.stringify(t).replace(/^"|"$/g,"")})).join('", "')}"]'::jsonb`}catch(e){console.error("Error parsing JSONB default value:",e),r+=" DEFAULT '[]'::jsonb"}else if("jsonb"===n.type)try{"string"==typeof t?t.endsWith("::jsonb")?r+=` DEFAULT '${t.replace(/::jsonb$/,"")}'::jsonb`:t.startsWith("{")||t.startsWith("[")?r+=` DEFAULT '${t}'::jsonb`:r+=` DEFAULT '${JSON.stringify(t)}'::jsonb`:r+=` DEFAULT '${JSON.stringify(t)}'::jsonb`}catch(e){console.error("Error parsing JSONB default value:",e),r+=" DEFAULT '{}'::jsonb"}else _(t)?r+=` DEFAULT ${t}`:r+=` DEFAULT ${w(t)}`}i.push(r)}if(c.length>0){const e=`  PRIMARY KEY (${c.map(A).join(", ")})`;i.push(e)}if(t)for(const[e,t]of Object.entries(r)){const r=t,a=o[e]?.name||e,s=`  CONSTRAINT ${A(`fk_${n}_${a}`)} FOREIGN KEY (${A(a)}) REFERENCES ${A(r.tableName)}(${A(r.columnName)})`;i.push(s)}s+=i.join(",\n"),s+="\n);\n";for(const[e,t]of Object.entries(a)){const r=o[e]?.name||e;s+=`ALTER TABLE ${A(n)} ADD COLUMN ${A(r)} vector(${t});\n`}return s}function R(e){const t={};let n=e;for(;n&&n.prototype;){const e=Reflect.getMetadata("columns",n)||{};for(const[n,o]of Object.entries(e))t[n]||(t[n]=o);n=Object.getPrototypeOf(n)}return t}function O(e,t){const n=Reflect.getMetadata("table:name",e),o=R(e),r=Reflect.getMetadata("foreign_keys",e)||{},a=Reflect.getMetadata("vector_columns",e)||{};let s="";for(const[e,r]of Object.entries(o)){const e=r,o=e.name;if(e.isVector)continue;const a=t.columns.find((e=>e.column_name===o));if(a){const t=[];e.nullable||"YES"!==a.is_nullable?e.nullable&&"NO"===a.is_nullable&&t.push(`ALTER COLUMN ${A(o)} DROP NOT NULL`):t.push(`ALTER COLUMN ${A(o)} SET NOT NULL`),e.type.toLowerCase()!==a.data_type.toLowerCase()&&t.push(`ALTER COLUMN ${A(o)} TYPE ${e.type} USING ${A(o)}::${e.type}`),t.length>0&&(s+=`ALTER TABLE ${A(n)} ${t.join(", ")};\n`)}else{let t=`${A(o)} ${e.type}`;if(e.nullable||(t+=" NOT NULL"),e.unique&&(t+=" UNIQUE"),e.default){const n=e.default();_(n)?t+=` DEFAULT ${n}`:t+=` DEFAULT ${w(n)}`}s+=`ALTER TABLE ${A(n)} ADD COLUMN ${t};\n`}}for(const[e,a]of Object.entries(r)){const r=a,i=o[e]?.name||e;t.foreignKeys.find((e=>e.column_name===i&&e.foreign_table_name===r.tableName&&e.foreign_column_name===r.columnName))||(s+=`ALTER TABLE ${A(n)} ADD CONSTRAINT ${A(`fk_${n}_${i}`)} FOREIGN KEY (${A(i)}) REFERENCES ${A(r.tableName)}(${A(r.columnName)});\n`)}for(const[e,r]of Object.entries(a)){const a=o[e]?.name||e;t.columns.find((e=>e.column_name===a))||(s+=`ALTER TABLE ${A(n)} ADD COLUMN ${A(a)} vector(${r});\n`)}return s}function T(e,t){const n=Reflect.getMetadata("table:name",e),o=R(e),r=Reflect.getMetadata("foreign_keys",e)||{};let a="";for(const[e,s]of Object.entries(r)){const r=s,i=o[e]?.name||e,c=`fk_${n}_${i}`,l=t[n];l&&l.foreignKeys&&l.foreignKeys.some((e=>e.column_name===i&&e.foreign_table_name===r.tableName&&e.foreign_column_name===r.columnName))||(a+=`ALTER TABLE ${A(n)} ADD CONSTRAINT ${A(c)} FOREIGN KEY (${A(i)}) REFERENCES ${A(r.tableName)}(${A(r.columnName)}) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;\n`)}return a}function L(e,t){let n="";n+="CREATE EXTENSION IF NOT EXISTS vector;\n\n",n+="-- First pass: Create all tables without foreign keys\n";for(const o of e){const e=Reflect.getMetadata("table:name",o);if(t[e]){const r=O(o,t[e]);r&&(n+=`-- Altering table ${e}\n${r}\n`)}else n+=`-- Creating table ${e}\n${N(o,!1)}\n`}n+="\n-- Second pass: Add foreign key constraints\n";for(const o of e){const e=Reflect.getMetadata("table:name",o),r=Reflect.getMetadata("foreign_keys",o)||{};Object.keys(r).length>0&&(n+=`-- Adding foreign keys to ${e}\n${T(o,t)}\n`)}return n}try{require("ts-node").register({project:"tsconfig.node.json",transpileOnly:!0,compilerOptions:{module:"CommonJS"}})}catch(e){console.log("ts-node not available, assuming TypeScript is already compiled")}async function S(e=!1){process.env.DATABASE_URL||(console.error("DATABASE_URL environment variable is not set"),process.exit(1));const n=new t.Pool({connectionString:process.env.DATABASE_URL});try{const t=await n.connect();try{e||await t.query("BEGIN"),e?console.log("Vector extension would be installed (dry run)"):await async function(e){try{await e.query("CREATE EXTENSION IF NOT EXISTS vector;"),console.log("Vector extension is installed or already exists.")}catch(e){throw console.error("Error ensuring vector extension:",e),e}}(n);const o=await h();console.log(`Loaded ${o.length} entity classes`);const r=await $(n);console.log(`Retrieved current schema with ${Object.keys(r).length} tables`);const a=L(o,r);"CREATE EXTENSION IF NOT EXISTS vector;"===a.trim()?console.log("No schema changes needed, database is up to date"):e?(console.log("DRY RUN: The following SQL would be executed:"),console.log(a),console.log("No changes were made to the database (dry run)")):(console.log("Executing migration SQL:"),console.log(a),await t.query(a),await t.query("COMMIT"),console.log("Migration completed")),e||await t.query("COMMIT")}catch(n){e||await t.query("ROLLBACK"),console.error("Migration failed:",n),process.exit(1)}finally{t.release()}}catch(e){console.error("Unhandled error during migration:",e),process.exit(1)}finally{await n.end()}}l.config(),require.main===module&&S().catch((e=>{console.error("Unhandled error during migration:",e),process.exit(1)})),exports.Column=function(e={}){return function(t,n){const o=t.constructor;let r=u.get(o);r||(r={},u.set(o,r));let a=e.type;if(!a){const e=function(e,t){const n=Reflect.getMetadata("design:type",e,t);if(!n)return"text";switch(n.name){case"String":default:return"text";case"Number":return"double precision";case"Boolean":return"boolean";case"Date":return"timestamp with time zone";case"Array":case"Object":return"jsonb"}}(t,n);if("jsonb"===e){const o=function(e,t){try{const n=(new e.constructor)[t];if(null==n)return t.toLowerCase().includes("date")||t.toLowerCase().includes("time")?"timestamp with time zone":t.toLowerCase().includes("price")||t.toLowerCase().includes("amount")||t.toLowerCase().includes("number")?"double precision":t.toLowerCase().includes("is")||t.toLowerCase().includes("has")||t.toLowerCase().includes("enable")||t.toLowerCase().includes("disable")?"boolean":"text";if("string"==typeof n)return"text";if("number"==typeof n)return"double precision";if("boolean"==typeof n)return"boolean";if(n instanceof Date)return"timestamp with time zone";if(Array.isArray(n))return"jsonb";if("object"==typeof n)return"jsonb"}catch(e){return null}return null}(t,n);a=o||e}else a=e}r[n]={name:e.name||n,primary:e.primary||!1,nullable:e.nullable||!1,unique:e.unique||!1,type:a,default:e.default},Reflect.defineMetadata("columns",r,o)}},exports.ForeignKey=function(e,t){return function(n,o){const r=n.constructor;let a=f.get(r);a||(a={},f.set(r,a)),a[o]={tableName:e,columnName:t},Reflect.defineMetadata("foreign_keys",a,r)}},exports.Table=function(e){return function(t){Reflect.defineMetadata("table:name",e.name,t),u.has(t)||u.set(t,{}),f.has(t)||f.set(t,{}),d.has(t)||d.set(t,{}),Reflect.defineMetadata("columns",u.get(t),t),Reflect.defineMetadata("foreign_keys",f.get(t),t),Reflect.defineMetadata("vector_columns",d.get(t),t)}},exports.VectorColumn=function(e){return function(t,n){const o=t.constructor;let r=u.get(o);var a;r||(r={},u.set(o,r)),r[n]={name:(a=n,a.replace(/[A-Z]/g,(e=>`_${e.toLowerCase()}`))),isVector:!0},Reflect.defineMetadata("columns",r,o);let s=d.get(o);s||(s={},d.set(o,s)),s[n]=e,Reflect.defineMetadata("vector_columns",s,o)}},exports.deleteBy=async function(e,t,n=m){const o=Reflect.getMetadata("table:name",e),r=b(e),a=[],s=[];let i=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=r[e],o=t?.name||e;a.push(`${o} = $${i}`),s.push(n),i++}if(0===a.length)return 0;const c=`\n    DELETE FROM ${o}\n    WHERE ${a.join(" AND ")}\n  `;return(await n.query(c,s)).rowCount||0},exports.ensureVectorDimensions=E,exports.escapeSqlString=w,exports.findBy=async function(e,t,n=m){const o=Reflect.getMetadata("table:name",e),r=b(e),a=[],s=[];let i=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=r[e],o=t?.name||e;a.push(`${o} = $${i}`),s.push(n),i++}if(0===a.length)return null;const c=`\n    SELECT * FROM ${o}\n    WHERE ${a.join(" AND ")}\n    LIMIT 1\n  `,l=await n.query(c,s);if(0===l.rows.length)return null;const u=new e;return Object.assign(u,g(l.rows[0],e)),u},exports.findSimilarEntries=async function(e,n=10,o=.5,r=m){const a=y(E(e,1536));let s=null,i=!1;try{r instanceof t.Pool?(s=await r.connect(),i=!0):s=r;return(await s.query("\n      SELECT \n        entry_id, \n        1 - (embedding <=> $1) as similarity\n      FROM \n        entry_embedding\n      WHERE \n        1 - (embedding <=> $1) > $2\n      ORDER BY \n        similarity DESC\n      LIMIT $3\n      ",[a,o,n])).rows.map((e=>({entryId:e.entry_id,similarity:e.similarity})))}catch(e){return console.error("Error finding similar entries:",e),[]}finally{i&&s&&s.release()}},exports.formatVector=y,exports.generateAlterTableSQL=O,exports.generateMigrationSQL=L,exports.generateTableSQL=N,exports.getCurrentSchema=$,exports.inferType=function(e,t){const n=Reflect.getMetadata("design:type",e,t);if(!n)return"text";switch(n.name){case"String":default:return"text";case"Number":return"double precision";case"Boolean":return"boolean";case"Date":return"timestamp with time zone";case"Array":case"Object":return"jsonb"}},exports.inferTypeFromValue=function(e,t){try{const n=(new e.constructor)[t];if(null==n)return t.toLowerCase().includes("date")||t.toLowerCase().includes("time")?"timestamp with time zone":t.toLowerCase().includes("price")||t.toLowerCase().includes("amount")||t.toLowerCase().includes("number")?"double precision":t.toLowerCase().includes("is")||t.toLowerCase().includes("has")||t.toLowerCase().includes("enable")||t.toLowerCase().includes("disable")?"boolean":"text";if("string"==typeof n)return"text";if("number"==typeof n)return"double precision";if("boolean"==typeof n)return"boolean";if(n instanceof Date)return"timestamp with time zone";if(Array.isArray(n))return"jsonb";if("object"==typeof n)return"jsonb"}catch(e){return null}return null},exports.isSqlFunction=_,exports.listAll=async function(e,t={},n=m){const o=Reflect.getMetadata("table:name",e),r=b(e),a=[],s=[];let i=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=r[e],o=t?.name||e;a.push(`${o} = $${i}`),s.push(n),i++}let c=`SELECT * FROM ${o}`;return a.length>0&&(c+=` WHERE ${a.join(" AND ")}`),(await n.query(c,s)).rows.map((t=>{const n=new e;return Object.assign(n,g(t,e)),n}))},exports.loadEntityClasses=h,exports.pool=m,exports.processVectorEmbeddings=p,exports.query=async function(e,t={},n=m){const{query:o,values:r}=function(e,t){const n=[],o={};let r=e.replace(/:([\w\d_]+)/g,((e,r)=>{if(void 0===t[r])throw new Error(`Missing parameter: ${r}`);return void 0===o[r]&&(o[r]=n.length+1,n.push(t[r])),`$${o[r]}`}));return{query:r,values:n}}(e,t);return(await n.query(o,r)).rows},exports.quoteIdentifier=A,exports.runMigration=S,exports.save=async function(t,n=m){const o=t.constructor,r=Reflect.getMetadata("table:name",o),a=b(o);if(p(t,o),!t.id){t.id=e.randomUUID(),t.createdAt=new Date,t.updatedAt=new Date;const s=[],i=[],c=[];let l=1;for(const[e,n]of Object.entries(a)){const o=t[e];if(void 0!==o){const t=n.name||e;s.push(t),i.push(`$${l}`),n.isVector&&Array.isArray(o)?c.push(y(o)):c.push(o),l++}}const u=`\n      INSERT INTO ${r} (${s.join(", ")})\n      VALUES (${i.join(", ")})\n      RETURNING *\n    `,f=await n.query(u,c);Object.assign(t,g(f.rows[0],o))}else{t.updatedAt=new Date;const e=[],s=[];let i=1;for(const[n,o]of Object.entries(a)){const r=t[n];if(void 0!==r&&"id"!==n&&"createdAt"!==n&&"updatedAt"!==n&&"deletedAt"!==n){const t=o.name||n;e.push(`${t} = $${i}`),o.isVector&&Array.isArray(r)?s.push(y(r)):s.push(r),i++}}e.push(`updated_at = $${i}`),s.push(t.updatedAt),i++,s.push(t.id);const c=`\n      UPDATE ${r}\n      SET ${e.join(", ")}\n      WHERE id = $${i}\n      RETURNING *\n    `,l=await n.query(c,s);Object.assign(t,g(l.rows[0],o))}return t},exports.storeEmbedding=async function(e,o,r=m){const a=E(o,1536),s=y(a);let i=null,c=!1;try{r instanceof t.Pool?(i=await r.connect(),c=!0):i=r;if(0===(await i.query("SELECT 1 FROM entry WHERE id = $1",[e])).rowCount)throw new Error(`Entry with ID ${e} does not exist`);const o=await i.query("SELECT id FROM entry_embedding WHERE entry_id = $1",[e]);if(o.rowCount&&o.rowCount>0)return await i.query("UPDATE entry_embedding SET embedding = $1, updated_at = NOW() WHERE entry_id = $2",[s,e]),{id:o.rows[0].id,entryId:e,embedding:a};return{id:(await i.query("INSERT INTO entry_embedding (id, entry_id, embedding, created_at, updated_at) VALUES ($1, $2, $3, NOW(), NOW()) RETURNING id",[n.v4(),e,s])).rows[0].id,entryId:e,embedding:a}}catch(e){throw console.error("Error storing embedding:",e),e}finally{c&&i&&i.release()}},exports.withSavepoint=async function(e,t,n){try{await n.query(`SAVEPOINT ${e}`);const o=await t();return await n.query(`RELEASE SAVEPOINT ${e}`),o}catch(t){throw await n.query(`ROLLBACK TO SAVEPOINT ${e}`),t}},exports.withTransaction=async function(e,t){const n=!t,o=t||await m.connect();try{await o.query("BEGIN");const t=await e(o);return await o.query("COMMIT"),t}catch(e){throw await o.query("ROLLBACK"),e}finally{n&&o.release()}};
//# sourceMappingURL=index.js.map
