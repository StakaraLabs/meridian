import"reflect-metadata";import e from"crypto";import{Pool as t}from"pg";import{v4 as n}from"uuid";import*as o from"fs";import*as r from"path";import*as a from"dotenv";const i=new WeakMap,s=new WeakMap,c=new WeakMap;function l(e){return function(t,n){return void 0===n?(o=t,Reflect.defineMetadata("table:name",e.name,o),i.has(o)||i.set(o,{}),s.has(o)||s.set(o,{}),c.has(o)||c.set(o,{}),Reflect.defineMetadata("columns",i.get(o),o),Reflect.defineMetadata("foreign_keys",s.get(o),o),Reflect.defineMetadata("vector_columns",c.get(o),o),o):function(t){const n=t;return Reflect.defineMetadata("table:name",e.name,n),i.has(n)||i.set(n,{}),s.has(n)||s.set(n,{}),c.has(n)||c.set(n,{}),Reflect.defineMetadata("columns",i.get(n),n),Reflect.defineMetadata("foreign_keys",s.get(n),n),Reflect.defineMetadata("vector_columns",c.get(n),n),t}(t);var o}}function u(e){return e.replace(/([A-Z])/g,"_$1").toLowerCase()}function f(e={}){return function(t,n){let o,r;"string"==typeof n?(o=n,r=t.constructor):(o=n.name,r=n.constructor);let a=i.get(r);a||(a={},i.set(r,a));let s=e.type;if(!s){const e=function(e,t){const n=Reflect.getMetadata("design:type",e,t);if(!n)return"text";switch(n.name){case"String":default:return"text";case"Number":return"double precision";case"Boolean":return"boolean";case"Date":return"timestamp with time zone";case"Array":case"Object":return"jsonb"}}(t,o);if("jsonb"===e){const n=function(e,t){try{const n=(new e.constructor)[t];if(null==n)return t.toLowerCase().includes("date")||t.toLowerCase().includes("time")?"timestamp with time zone":t.toLowerCase().includes("price")||t.toLowerCase().includes("amount")||t.toLowerCase().includes("number")?"double precision":t.toLowerCase().includes("is")||t.toLowerCase().includes("has")||t.toLowerCase().includes("enable")||t.toLowerCase().includes("disable")?"boolean":"text";if("string"==typeof n)return"text";if("number"==typeof n)return"double precision";if("boolean"==typeof n)return"boolean";if(n instanceof Date)return"timestamp with time zone";if(Array.isArray(n))return"jsonb";if("object"==typeof n)return"jsonb"}catch(e){return null}return null}(t,o);s=n||e}else s=e}a[o]={name:e.name||u(o),primary:e.primary||!1,nullable:e.nullable||!1,unique:e.unique||!1,type:s,default:e.default},Reflect.defineMetadata("columns",a,r)}}function m(e,t){return function(n,o){let r,a;"string"==typeof o?(r=o,a=n.constructor):(r=o.name,a=o.constructor);let i=s.get(a);i||(i={},s.set(a,i)),i[r]={tableName:e,columnName:t},Reflect.defineMetadata("foreign_keys",i,a)}}function d(e){return function(t,n){let o,r;"string"==typeof n?(o=n,r=t.constructor):(o=n.name,r=n.constructor);let a=i.get(r);a||(a={},i.set(r,a)),a[o]={name:u(o),isVector:!0},Reflect.defineMetadata("columns",a,r);let s=c.get(r);s||(s={},c.set(r,s)),s[o]=e,Reflect.defineMetadata("vector_columns",s,r)}}let y;function E(e){if(!e||!Array.isArray(e))throw new Error("Vector must be an array of numbers");return`[${e.join(",")}]`}function g(e,t){return e&&Array.isArray(e)?e.length!==t?(console.warn(`Expected embedding dimension of ${t}, but got ${e.length}. Padding or truncating.`),e.length>t?e.slice(0,t):[...e,...Array(t-e.length).fill(0)]):e:(console.warn(`Invalid vector: ${e}`),Array(t).fill(0))}function p(e,t){const n=Reflect.getMetadata("vector_columns",t);if(n){Reflect.getMetadata("columns",t);for(const[t,o]of Object.entries(n)){const n=e[t];if(!n||!Array.isArray(n))continue;const r=g(n,o);e[t]=r}}}async function b(e,o,r=y){const a=g(o,1536),i=E(a);let s=null,c=!1;try{r instanceof t?(s=await r.connect(),c=!0):s=r;if(0===(await s.query("SELECT 1 FROM entry WHERE id = $1",[e])).rowCount)throw new Error(`Entry with ID ${e} does not exist`);const o=await s.query("SELECT id FROM entry_embedding WHERE entry_id = $1",[e]);if(o.rowCount&&o.rowCount>0)return await s.query("UPDATE entry_embedding SET embedding = $1, updated_at = NOW() WHERE entry_id = $2",[i,e]),{id:o.rows[0].id,entryId:e,embedding:a};return{id:(await s.query("INSERT INTO entry_embedding (id, entry_id, embedding, created_at, updated_at) VALUES ($1, $2, $3, NOW(), NOW()) RETURNING id",[n(),e,i])).rows[0].id,entryId:e,embedding:a}}catch(e){throw console.error("Error storing embedding:",e),e}finally{c&&s&&s.release()}}async function w(e,n=10,o=.5,r=y){const a=E(g(e,1536));let i=null,s=!1;try{r instanceof t?(i=await r.connect(),s=!0):i=r;return(await i.query("\n      SELECT \n        entry_id, \n        1 - (embedding <=> $1) as similarity\n      FROM \n        entry_embedding\n      WHERE \n        1 - (embedding <=> $1) > $2\n      ORDER BY \n        similarity DESC\n      LIMIT $3\n      ",[a,o,n])).rows.map((e=>({entryId:e.entry_id,similarity:e.similarity})))}catch(e){return console.error("Error finding similar entries:",e),[]}finally{s&&i&&i.release()}}async function h(e,t,n=y){const o=Reflect.getMetadata("table:name",e),r=O(e),a=[],i=[];let s=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=r[e];if(!t)throw new Error(`Property ${e} is not decorated with @Column`);const o=t.name;a.push(`${o} = $${s}`),i.push(n),s++}if(0===a.length)return null;const c=`\n    SELECT * FROM ${o}\n    WHERE ${a.join(" AND ")}\n    LIMIT 1\n  `,l=await n.query(c,i);if(0===l.rows.length)return null;const u=new e;return Object.assign(u,N(l.rows[0],e)),u}async function $(e,t={},n=y){const o=Reflect.getMetadata("table:name",e),r=O(e),a=[],i=[];let s=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=r[e];if(!t)throw new Error(`Property ${e} is not decorated with @Column`);const o=t.name;a.push(`${o} = $${s}`),i.push(n),s++}let c=`SELECT * FROM ${o}`;a.length>0&&(c+=` WHERE ${a.join(" AND ")}`);return(await n.query(c,i)).rows.map((t=>{const n=new e;return Object.assign(n,N(t,e)),n}))}async function A(e,t={},n=y){const{query:o,values:r}=function(e,t){const n=[],o={};let r=e.replace(/:([\w\d_]+)/g,((e,r)=>{if(void 0===t[r])throw new Error(`Missing parameter: ${r}`);return void 0===o[r]&&(o[r]=n.length+1,n.push(t[r])),`$${o[r]}`}));return{query:r,values:n}}(e,t);return(await n.query(o,r)).rows}async function _(t,n=y){const o=t.constructor,r=Reflect.getMetadata("table:name",o),a=O(o);p(t,o);if(!t.id){t.id=e.randomUUID(),t.createdAt=new Date,t.updatedAt=new Date;const i=[],s=[],c=[];let l=1;for(const[e,n]of Object.entries(a)){const o=t[e];if(void 0!==o){const e=n.name;i.push(e),s.push(`$${l}`),n.isVector&&Array.isArray(o)?c.push(E(o)):c.push(o),l++}}const u=`\n      INSERT INTO ${r} (${i.join(", ")})\n      VALUES (${s.join(", ")})\n      RETURNING *\n    `,f=await n.query(u,c);Object.assign(t,N(f.rows[0],o))}else{t.updatedAt=new Date;const e=[],i=[];let s=1;for(const[n,o]of Object.entries(a)){const r=t[n];if(void 0!==r&&"id"!==n&&"createdAt"!==n&&"updatedAt"!==n&&"deletedAt"!==n){const t=o.name;e.push(`${t} = $${s}`),o.isVector&&Array.isArray(r)?i.push(E(r)):i.push(r),s++}}e.push(`updated_at = $${s}`),i.push(t.updatedAt),s++,i.push(t.id);const c=`\n      UPDATE ${r}\n      SET ${e.join(", ")}\n      WHERE id = $${s}\n      RETURNING *\n    `,l=await n.query(c,i);Object.assign(t,N(l.rows[0],o))}return t}async function R(e,t,n=y){const o=Reflect.getMetadata("table:name",e),r=O(e),a=[],i=[];let s=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=r[e];if(!t)throw new Error(`Property ${e} is not decorated with @Column`);const o=t.name;a.push(`${o} = $${s}`),i.push(n),s++}if(0===a.length)return 0;const c=`\n    DELETE FROM ${o}\n    WHERE ${a.join(" AND ")}\n  `;return(await n.query(c,i)).rowCount||0}function N(e,t){const n={},o=O(t);for(const[t,r]of Object.entries(o)){const o=r.name.toLowerCase();void 0!==e[o]&&(n[t]=e[o])}return n}function O(e){const t=Reflect.getMetadata("columns",e)||{};let n=Object.getPrototypeOf(e);for(;n&&n.name;){const e=Reflect.getMetadata("columns",n);e&&Object.assign(t,e),n=Object.getPrototypeOf(n)}return t}async function L(e,t){const n=!t,o=t||await y.connect();try{await o.query("BEGIN");const t=await e(o);return await o.query("COMMIT"),t}catch(e){throw await o.query("ROLLBACK"),e}finally{n&&o.release()}}async function T(e,t,n){try{await n.query(`SAVEPOINT ${e}`);const o=await t();return await n.query(`RELEASE SAVEPOINT ${e}`),o}catch(t){throw await n.query(`ROLLBACK TO SAVEPOINT ${e}`),t}}function C(e){return["all","analyse","analyze","and","any","array","as","asc","asymmetric","authorization","binary","both","case","cast","check","collate","column","constraint","create","cross","current_catalog","current_date","current_role","current_schema","current_time","current_timestamp","current_user","default","deferrable","desc","distinct","do","else","end","except","false","fetch","for","foreign","freeze","from","full","grant","group","having","ilike","in","initially","inner","intersect","into","is","isnull","join","lateral","leading","left","like","limit","localtime","localtimestamp","natural","not","notnull","null","offset","on","only","or","order","outer","overlaps","placing","primary","references","returning","right","select","session_user","similar","some","symmetric","table","tablesample","then","to","trailing","true","union","unique","user","using","variadic","verbose","when","where","window","with"].includes(e.toLowerCase())||/[^a-zA-Z0-9_]/.test(e)||/^[0-9]/.test(e)?`"${e}"`:e}function S(e){return`'${e.replace(/'/g,"''")}'`}function M(e){return"string"==typeof e&&/^[a-zA-Z0-9_]+\(.*\)$/.test(e)}async function j(){const e=[],t=r.join(process.cwd(),"db","entities");try{const n=o.readdirSync(t,{withFileTypes:!0});for(const o of n)if(!o.isDirectory()&&(o.name.endsWith(".ts")||o.name.endsWith(".js")))try{const n=r.join(t,o.name),a=await import(n);for(const t of Object.keys(a)){const n=a[t];"function"==typeof n&&Reflect.hasMetadata("table:name",n)&&e.push(n)}}catch(e){console.warn(`Error loading entity file ${o.name}:`,e)}}catch(e){console.warn("Error reading entities directory:",e)}return e}async function D(e){const t={},n=await e.query("\n    SELECT table_name\n    FROM information_schema.tables\n    WHERE table_schema = 'public'\n    AND table_type = 'BASE TABLE'\n  ");for(const o of n.rows){const n=o.table_name;t[n]={columns:[],primaryKey:[],foreignKeys:[],indexes:[]};const r=await e.query("\n      SELECT \n        column_name, \n        data_type, \n        is_nullable, \n        column_default\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n      AND table_name = $1\n    ",[n]);t[n].columns=r.rows;const a=await e.query("\n      SELECT a.attname\n      FROM pg_index i\n      JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)\n      WHERE i.indrelid = $1::regclass\n      AND i.indisprimary\n    ",[n]);t[n].primaryKey=a.rows.map((e=>e.attname));const i=await e.query("\n      SELECT\n        kcu.column_name,\n        ccu.table_name AS foreign_table_name,\n        ccu.column_name AS foreign_column_name\n      FROM information_schema.table_constraints AS tc\n      JOIN information_schema.key_column_usage AS kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      JOIN information_schema.constraint_column_usage AS ccu\n        ON ccu.constraint_name = tc.constraint_name\n        AND ccu.table_schema = tc.table_schema\n      WHERE tc.constraint_type = 'FOREIGN KEY'\n      AND tc.table_name = $1\n    ",[n]);t[n].foreignKeys=i.rows;const s=await e.query("\n      SELECT\n        kcu.column_name\n      FROM information_schema.table_constraints AS tc\n      JOIN information_schema.key_column_usage AS kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      WHERE tc.constraint_type = 'UNIQUE'\n      AND tc.table_name = $1\n    ",[n]);for(const e of s.rows){const o=t[n].columns.find((t=>t.column_name===e.column_name));o&&(o.is_unique=!0)}const c=await e.query("\n      SELECT\n        i.relname AS index_name,\n        array_agg(a.attname) AS column_names,\n        ix.indisunique AS is_unique\n      FROM pg_class t\n      JOIN pg_index ix ON t.oid = ix.indrelid\n      JOIN pg_class i ON i.oid = ix.indexrelid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      WHERE t.relkind = 'r'\n      AND t.relname = $1\n      AND i.relname NOT IN (\n        SELECT constraint_name\n        FROM information_schema.table_constraints\n        WHERE table_name = $1\n        AND constraint_type IN ('PRIMARY KEY', 'UNIQUE')\n      )\n      GROUP BY i.relname, ix.indisunique\n    ",[n]);t[n].indexes=c.rows}return t}function I(e,t=!0){const n=Reflect.getMetadata("table:name",e),o=U(e),r=Reflect.getMetadata("foreign_keys",e)||{},a=Reflect.getMetadata("vector_columns",e)||{};let i=`CREATE TABLE ${C(n)} (\n`;const s=[],c=[];for(const[e,t]of Object.entries(o)){const n=t,o=n.name;if(n.isVector)continue;let r=`  ${C(o)} ${n.type}`;if(n.primary&&c.push(o),n.nullable||(r+=" NOT NULL"),n.unique&&(r+=" UNIQUE"),n.default){const t=n.default();if("jsonb"===n.type&&t.startsWith("ARRAY["))if("promptTypes"===e)r+=' DEFAULT \'["reflection", "questions", "encouragement"]\'::jsonb';else if("preferredTags"===e||"excludedTags"===e)r+=" DEFAULT '[]'::jsonb";else try{const e=t.substring(6,t.length-1);r+=` DEFAULT '["${e.split(",").map((e=>{const t=e.replace(/^'|'$/g,"").trim();return JSON.stringify(t).replace(/^"|"$/g,"")})).join('", "')}"]'::jsonb`}catch(e){console.error("Error parsing JSONB default value:",e),r+=" DEFAULT '[]'::jsonb"}else if("jsonb"===n.type)try{"string"==typeof t?t.endsWith("::jsonb")?r+=` DEFAULT '${t.replace(/::jsonb$/,"")}'::jsonb`:t.startsWith("{")||t.startsWith("[")?r+=` DEFAULT '${t}'::jsonb`:r+=` DEFAULT '${JSON.stringify(t)}'::jsonb`:r+=` DEFAULT '${JSON.stringify(t)}'::jsonb`}catch(e){console.error("Error parsing JSONB default value:",e),r+=" DEFAULT '{}'::jsonb"}else M(t)?r+=` DEFAULT ${t}`:r+=` DEFAULT ${S(t)}`}s.push(r)}if(c.length>0){const e=`  PRIMARY KEY (${c.map(C).join(", ")})`;s.push(e)}if(t)for(const[e,t]of Object.entries(r)){const r=t,a=o[e];if(!a)throw new Error(`Property ${e} is not decorated with @Column`);const i=a.name,c=`  CONSTRAINT ${C(`fk_${n}_${i}`)} FOREIGN KEY (${C(i)}) REFERENCES ${C(r.tableName)}(${C(r.columnName)})`;s.push(c)}i+=s.join(",\n"),i+="\n);\n";for(const[e,t]of Object.entries(a)){const r=o[e];if(!r)throw new Error(`Property ${e} is not decorated with @Column`);const a=r.name;i+=`ALTER TABLE ${C(n)} ADD COLUMN ${C(a)} vector(${t});\n`}return i}function U(e){const t={};let n=e;for(;n&&n.prototype;){const e=Reflect.getMetadata("columns",n)||{};for(const[n,o]of Object.entries(e))t[n]||(t[n]=o);n=Object.getPrototypeOf(n)}return t}function q(e,t){const n=Reflect.getMetadata("table:name",e),o=U(e),r=Reflect.getMetadata("foreign_keys",e)||{},a=Reflect.getMetadata("vector_columns",e)||{};let i="";for(const[e,r]of Object.entries(o)){const e=r,o=e.name;if(e.isVector)continue;const a=t.columns.find((e=>e.column_name===o));if(a){const t=[];e.nullable||"YES"!==a.is_nullable?e.nullable&&"NO"===a.is_nullable&&t.push(`ALTER COLUMN ${C(o)} DROP NOT NULL`):t.push(`ALTER COLUMN ${C(o)} SET NOT NULL`),e.type.toLowerCase()!==a.data_type.toLowerCase()&&t.push(`ALTER COLUMN ${C(o)} TYPE ${e.type} USING ${C(o)}::${e.type}`),t.length>0&&(i+=`ALTER TABLE ${C(n)} ${t.join(", ")};\n`)}else{let t=`${C(o)} ${e.type}`;if(e.nullable||(t+=" NOT NULL"),e.unique&&(t+=" UNIQUE"),e.default){const n=e.default();M(n)?t+=` DEFAULT ${n}`:t+=` DEFAULT ${S(n)}`}i+=`ALTER TABLE ${C(n)} ADD COLUMN ${t};\n`}}for(const[e,a]of Object.entries(r)){const r=a,s=o[e];if(!s)throw new Error(`Property ${e} is not decorated with @Column`);const c=s.name;t.foreignKeys.find((e=>e.column_name===c&&e.foreign_table_name===r.tableName&&e.foreign_column_name===r.columnName))||(i+=`ALTER TABLE ${C(n)} ADD CONSTRAINT ${C(`fk_${n}_${c}`)} FOREIGN KEY (${C(c)}) REFERENCES ${C(r.tableName)}(${C(r.columnName)});\n`)}for(const[e,r]of Object.entries(a)){const a=o[e];if(!a)throw new Error(`Property ${e} is not decorated with @Column`);const s=a.name;t.columns.find((e=>e.column_name===s))||(i+=`ALTER TABLE ${C(n)} ADD COLUMN ${C(s)} vector(${r});\n`)}return i}function F(e,t){const n=Reflect.getMetadata("table:name",e),o=U(e),r=Reflect.getMetadata("foreign_keys",e)||{};let a="";for(const[e,i]of Object.entries(r)){const r=i,s=o[e];if(!s)throw new Error(`Property ${e} is not decorated with @Column`);const c=s.name,l=`fk_${n}_${c}`,u=t[n];u&&u.foreignKeys&&u.foreignKeys.some((e=>e.column_name===c&&e.foreign_table_name===r.tableName&&e.foreign_column_name===r.columnName))||(a+=`ALTER TABLE ${C(n)} ADD CONSTRAINT ${C(l)} FOREIGN KEY (${C(c)}) REFERENCES ${C(r.tableName)}(${C(r.columnName)}) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;\n`)}return a}function v(e,t){let n="";n+="CREATE EXTENSION IF NOT EXISTS vector;\n\n",n+="-- First pass: Create all tables without foreign keys\n";for(const o of e){const e=Reflect.getMetadata("table:name",o);if(t[e]){const r=q(o,t[e]);r&&(n+=`-- Altering table ${e}\n${r}\n`)}else n+=`-- Creating table ${e}\n${I(o,!1)}\n`}n+="\n-- Second pass: Add foreign key constraints\n";for(const o of e){const e=Reflect.getMetadata("table:name",o),r=Reflect.getMetadata("foreign_keys",o)||{};Object.keys(r).length>0&&(n+=`-- Adding foreign keys to ${e}\n${F(o,t)}\n`)}return n}function k(e,t){const n=Reflect.getMetadata("design:type",e,t);if(!n)return"text";switch(n.name){case"String":default:return"text";case"Number":return"double precision";case"Boolean":return"boolean";case"Date":return"timestamp with time zone";case"Array":case"Object":return"jsonb"}}function x(e,t){try{const n=(new e.constructor)[t];if(null==n)return t.toLowerCase().includes("date")||t.toLowerCase().includes("time")?"timestamp with time zone":t.toLowerCase().includes("price")||t.toLowerCase().includes("amount")||t.toLowerCase().includes("number")?"double precision":t.toLowerCase().includes("is")||t.toLowerCase().includes("has")||t.toLowerCase().includes("enable")||t.toLowerCase().includes("disable")?"boolean":"text";if("string"==typeof n)return"text";if("number"==typeof n)return"double precision";if("boolean"==typeof n)return"boolean";if(n instanceof Date)return"timestamp with time zone";if(Array.isArray(n))return"jsonb";if("object"==typeof n)return"jsonb"}catch(e){return null}return null}try{require("ts-node").register({project:"tsconfig.node.json",transpileOnly:!0,compilerOptions:{module:"CommonJS"}})}catch(e){console.log("ts-node not available, assuming TypeScript is already compiled")}async function W(e,n=!1,o){let r=!1,a="";try{if(!e){if(!process.env.DATABASE_URL)throw new Error("DATABASE_URL environment variable is not set");e=new t({connectionString:process.env.DATABASE_URL}),r=!0}const i=await e.connect();try{n||await i.query("BEGIN"),n?console.log("Vector extension would be installed (dry run)"):await async function(e){try{await e.query("CREATE EXTENSION IF NOT EXISTS vector;"),console.log("Vector extension is installed or already exists.")}catch(e){throw console.error("Error ensuring vector extension:",e),e}}(e),o||(o=await j()),console.log(`Loaded ${o.length} entity classes`);const t=await D(e);console.log(`Retrieved current schema with ${Object.keys(t).length} tables`),a=v(o,t),"CREATE EXTENSION IF NOT EXISTS vector;"===a.trim()?console.log("No schema changes needed, database is up to date"):n?(console.log("DRY RUN: The following SQL would be executed:"),console.log(a),console.log("No changes were made to the database (dry run)")):(console.log("Executing migration SQL:"),console.log(a),await i.query(a),console.log("Migration completed")),n||await i.query("COMMIT")}catch(e){throw n||await i.query("ROLLBACK"),console.error("Migration failed:",e),e}finally{i.release()}}finally{r&&e&&await e.end()}return a}a.config(),require.main===module&&W().catch((e=>{console.error("Unhandled error during migration:",e),process.exit(1)}));export{f as Column,m as ForeignKey,l as Table,d as VectorColumn,R as deleteBy,g as ensureVectorDimensions,S as escapeSqlString,h as findBy,w as findSimilarEntries,E as formatVector,q as generateAlterTableSQL,v as generateMigrationSQL,I as generateTableSQL,D as getCurrentSchema,k as inferType,x as inferTypeFromValue,M as isSqlFunction,$ as listAll,j as loadEntityClasses,y as pool,p as processVectorEmbeddings,A as query,C as quoteIdentifier,W as runMigration,_ as save,b as storeEmbedding,T as withSavepoint,L as withTransaction};
//# sourceMappingURL=index.esm.js.map
