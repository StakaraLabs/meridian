import"reflect-metadata";import e from"crypto";import{Pool as t}from"pg";import{v4 as n}from"uuid";import*as o from"fs";import*as a from"path";import*as r from"dotenv";const i=new WeakMap,s=new WeakMap,c=new WeakMap;function l(e){return function(t){Reflect.defineMetadata("table:name",e.name,t),i.has(t)||i.set(t,{}),s.has(t)||s.set(t,{}),c.has(t)||c.set(t,{}),Reflect.defineMetadata("columns",i.get(t),t),Reflect.defineMetadata("foreign_keys",s.get(t),t),Reflect.defineMetadata("vector_columns",c.get(t),t)}}function u(e={}){return function(t,n){const o=t.constructor;let a=i.get(o);a||(a={},i.set(o,a));let r=e.type;if(!r){const e=function(e,t){const n=Reflect.getMetadata("design:type",e,t);if(!n)return"text";switch(n.name){case"String":default:return"text";case"Number":return"double precision";case"Boolean":return"boolean";case"Date":return"timestamp with time zone";case"Array":case"Object":return"jsonb"}}(t,n);if("jsonb"===e){const o=function(e,t){try{const n=(new e.constructor)[t];if(null==n)return t.toLowerCase().includes("date")||t.toLowerCase().includes("time")?"timestamp with time zone":t.toLowerCase().includes("price")||t.toLowerCase().includes("amount")||t.toLowerCase().includes("number")?"double precision":t.toLowerCase().includes("is")||t.toLowerCase().includes("has")||t.toLowerCase().includes("enable")||t.toLowerCase().includes("disable")?"boolean":"text";if("string"==typeof n)return"text";if("number"==typeof n)return"double precision";if("boolean"==typeof n)return"boolean";if(n instanceof Date)return"timestamp with time zone";if(Array.isArray(n))return"jsonb";if("object"==typeof n)return"jsonb"}catch(e){return null}return null}(t,n);r=o||e}else r=e}a[n]={name:e.name||n,primary:e.primary||!1,nullable:e.nullable||!1,unique:e.unique||!1,type:r,default:e.default},Reflect.defineMetadata("columns",a,o)}}function f(e,t){return function(n,o){const a=n.constructor;let r=s.get(a);r||(r={},s.set(a,r)),r[o]={tableName:e,columnName:t},Reflect.defineMetadata("foreign_keys",r,a)}}function m(e){return function(t,n){const o=t.constructor;let a=i.get(o);var r;a||(a={},i.set(o,a)),a[n]={name:(r=n,r.replace(/[A-Z]/g,(e=>`_${e.toLowerCase()}`))),isVector:!0},Reflect.defineMetadata("columns",a,o);let s=c.get(o);s||(s={},c.set(o,s)),s[n]=e,Reflect.defineMetadata("vector_columns",s,o)}}const d=new t({connectionString:process.env.DATABASE_URL});function y(e){if(!e||!Array.isArray(e))throw new Error("Vector must be an array of numbers");return`[${e.join(",")}]`}function E(e,t){return e&&Array.isArray(e)?e.length!==t?(console.warn(`Expected embedding dimension of ${t}, but got ${e.length}. Padding or truncating.`),e.length>t?e.slice(0,t):[...e,...Array(t-e.length).fill(0)]):e:(console.warn(`Invalid vector: ${e}`),Array(t).fill(0))}function g(e,t){const n=Reflect.getMetadata("vector_columns",t);if(n){Reflect.getMetadata("columns",t);for(const[t,o]of Object.entries(n)){const n=e[t];if(!n||!Array.isArray(n))continue;const a=E(n,o);e[t]=a}}}async function b(e,o,a=d){const r=E(o,1536),i=y(r);let s=null,c=!1;try{a instanceof t?(s=await a.connect(),c=!0):s=a;if(0===(await s.query("SELECT 1 FROM entry WHERE id = $1",[e])).rowCount)throw new Error(`Entry with ID ${e} does not exist`);const o=await s.query("SELECT id FROM entry_embedding WHERE entry_id = $1",[e]);if(o.rowCount&&o.rowCount>0)return await s.query("UPDATE entry_embedding SET embedding = $1, updated_at = NOW() WHERE entry_id = $2",[i,e]),{id:o.rows[0].id,entryId:e,embedding:r};return{id:(await s.query("INSERT INTO entry_embedding (id, entry_id, embedding, created_at, updated_at) VALUES ($1, $2, $3, NOW(), NOW()) RETURNING id",[n(),e,i])).rows[0].id,entryId:e,embedding:r}}catch(e){throw console.error("Error storing embedding:",e),e}finally{c&&s&&s.release()}}async function p(e,n=10,o=.5,a=d){const r=y(E(e,1536));let i=null,s=!1;try{a instanceof t?(i=await a.connect(),s=!0):i=a;return(await i.query("\n      SELECT \n        entry_id, \n        1 - (embedding <=> $1) as similarity\n      FROM \n        entry_embedding\n      WHERE \n        1 - (embedding <=> $1) > $2\n      ORDER BY \n        similarity DESC\n      LIMIT $3\n      ",[r,o,n])).rows.map((e=>({entryId:e.entry_id,similarity:e.similarity})))}catch(e){return console.error("Error finding similar entries:",e),[]}finally{s&&i&&i.release()}}async function A(e,t,n=d){const o=Reflect.getMetadata("table:name",e),a=R(e),r=[],i=[];let s=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=a[e],o=t?.name||e;r.push(`${o} = $${s}`),i.push(n),s++}if(0===r.length)return null;const c=`\n    SELECT * FROM ${o}\n    WHERE ${r.join(" AND ")}\n    LIMIT 1\n  `,l=await n.query(c,i);if(0===l.rows.length)return null;const u=new e;return Object.assign(u,N(l.rows[0],e)),u}async function w(e,t={},n=d){const o=Reflect.getMetadata("table:name",e),a=R(e),r=[],i=[];let s=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=a[e],o=t?.name||e;r.push(`${o} = $${s}`),i.push(n),s++}let c=`SELECT * FROM ${o}`;r.length>0&&(c+=` WHERE ${r.join(" AND ")}`);return(await n.query(c,i)).rows.map((t=>{const n=new e;return Object.assign(n,N(t,e)),n}))}async function _(e,t={},n=d){const{query:o,values:a}=function(e,t){const n=[],o={};let a=e.replace(/:([\w\d_]+)/g,((e,a)=>{if(void 0===t[a])throw new Error(`Missing parameter: ${a}`);return void 0===o[a]&&(o[a]=n.length+1,n.push(t[a])),`$${o[a]}`}));return{query:a,values:n}}(e,t);return(await n.query(o,a)).rows}async function $(t,n=d){const o=t.constructor,a=Reflect.getMetadata("table:name",o),r=R(o);g(t,o);if(!t.id){t.id=e.randomUUID(),t.createdAt=new Date,t.updatedAt=new Date;const i=[],s=[],c=[];let l=1;for(const[e,n]of Object.entries(r)){const o=t[e];if(void 0!==o){const t=n.name||e;i.push(t),s.push(`$${l}`),n.isVector&&Array.isArray(o)?c.push(y(o)):c.push(o),l++}}const u=`\n      INSERT INTO ${a} (${i.join(", ")})\n      VALUES (${s.join(", ")})\n      RETURNING *\n    `,f=await n.query(u,c);Object.assign(t,N(f.rows[0],o))}else{t.updatedAt=new Date;const e=[],i=[];let s=1;for(const[n,o]of Object.entries(r)){const a=t[n];if(void 0!==a&&"id"!==n&&"createdAt"!==n&&"updatedAt"!==n&&"deletedAt"!==n){const t=o.name||n;e.push(`${t} = $${s}`),o.isVector&&Array.isArray(a)?i.push(y(a)):i.push(a),s++}}e.push(`updated_at = $${s}`),i.push(t.updatedAt),s++,i.push(t.id);const c=`\n      UPDATE ${a}\n      SET ${e.join(", ")}\n      WHERE id = $${s}\n      RETURNING *\n    `,l=await n.query(c,i);Object.assign(t,N(l.rows[0],o))}return t}async function h(e,t,n=d){const o=Reflect.getMetadata("table:name",e),a=R(e),r=[],i=[];let s=1;for(const[e,n]of Object.entries(t))if(void 0!==n){const t=a[e],o=t?.name||e;r.push(`${o} = $${s}`),i.push(n),s++}if(0===r.length)return 0;const c=`\n    DELETE FROM ${o}\n    WHERE ${r.join(" AND ")}\n  `;return(await n.query(c,i)).rowCount||0}function N(e,t){const n={},o=R(t);for(const[t,a]of Object.entries(o)){const o=(a.name||t).toLowerCase();void 0!==e[o]&&(n[t]=e[o])}return n}function R(e){const t=Reflect.getMetadata("columns",e)||{};let n=Object.getPrototypeOf(e);for(;n&&n.name;){const e=Reflect.getMetadata("columns",n);e&&Object.assign({},e,t),n=Object.getPrototypeOf(n)}return t}async function O(e,t){const n=!t,o=t||await d.connect();try{await o.query("BEGIN");const t=await e(o);return await o.query("COMMIT"),t}catch(e){throw await o.query("ROLLBACK"),e}finally{n&&o.release()}}async function L(e,t,n){try{await n.query(`SAVEPOINT ${e}`);const o=await t();return await n.query(`RELEASE SAVEPOINT ${e}`),o}catch(t){throw await n.query(`ROLLBACK TO SAVEPOINT ${e}`),t}}function T(e){return["all","analyse","analyze","and","any","array","as","asc","asymmetric","authorization","binary","both","case","cast","check","collate","column","constraint","create","cross","current_catalog","current_date","current_role","current_schema","current_time","current_timestamp","current_user","default","deferrable","desc","distinct","do","else","end","except","false","fetch","for","foreign","freeze","from","full","grant","group","having","ilike","in","initially","inner","intersect","into","is","isnull","join","lateral","leading","left","like","limit","localtime","localtimestamp","natural","not","notnull","null","offset","on","only","or","order","outer","overlaps","placing","primary","references","returning","right","select","session_user","similar","some","symmetric","table","tablesample","then","to","trailing","true","union","unique","user","using","variadic","verbose","when","where","window","with"].includes(e.toLowerCase())||/[^a-zA-Z0-9_]/.test(e)||/^[0-9]/.test(e)?`"${e}"`:e}function S(e){return`'${e.replace(/'/g,"''")}'`}function j(e){return"string"==typeof e&&/^[a-zA-Z0-9_]+\(.*\)$/.test(e)}async function C(){const e=[],t=a.join(process.cwd(),"db","entities");try{const n=o.readdirSync(t,{withFileTypes:!0});for(const o of n)if(!o.isDirectory()&&(o.name.endsWith(".ts")||o.name.endsWith(".js")))try{const n=a.join(t,o.name),r=await import(n);for(const t of Object.keys(r)){const n=r[t];"function"==typeof n&&Reflect.hasMetadata("table:name",n)&&e.push(n)}}catch(e){console.warn(`Error loading entity file ${o.name}:`,e)}}catch(e){console.warn("Error reading entities directory:",e)}return e}async function M(e){const t={},n=await e.query("\n    SELECT table_name\n    FROM information_schema.tables\n    WHERE table_schema = 'public'\n    AND table_type = 'BASE TABLE'\n  ");for(const o of n.rows){const n=o.table_name;t[n]={columns:[],primaryKey:[],foreignKeys:[],indexes:[]};const a=await e.query("\n      SELECT \n        column_name, \n        data_type, \n        is_nullable, \n        column_default\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n      AND table_name = $1\n    ",[n]);t[n].columns=a.rows;const r=await e.query("\n      SELECT a.attname\n      FROM pg_index i\n      JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)\n      WHERE i.indrelid = $1::regclass\n      AND i.indisprimary\n    ",[n]);t[n].primaryKey=r.rows.map((e=>e.attname));const i=await e.query("\n      SELECT\n        kcu.column_name,\n        ccu.table_name AS foreign_table_name,\n        ccu.column_name AS foreign_column_name\n      FROM information_schema.table_constraints AS tc\n      JOIN information_schema.key_column_usage AS kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      JOIN information_schema.constraint_column_usage AS ccu\n        ON ccu.constraint_name = tc.constraint_name\n        AND ccu.table_schema = tc.table_schema\n      WHERE tc.constraint_type = 'FOREIGN KEY'\n      AND tc.table_name = $1\n    ",[n]);t[n].foreignKeys=i.rows;const s=await e.query("\n      SELECT\n        kcu.column_name\n      FROM information_schema.table_constraints AS tc\n      JOIN information_schema.key_column_usage AS kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      WHERE tc.constraint_type = 'UNIQUE'\n      AND tc.table_name = $1\n    ",[n]);for(const e of s.rows){const o=t[n].columns.find((t=>t.column_name===e.column_name));o&&(o.is_unique=!0)}const c=await e.query("\n      SELECT\n        i.relname AS index_name,\n        array_agg(a.attname) AS column_names,\n        ix.indisunique AS is_unique\n      FROM pg_class t\n      JOIN pg_index ix ON t.oid = ix.indrelid\n      JOIN pg_class i ON i.oid = ix.indexrelid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      WHERE t.relkind = 'r'\n      AND t.relname = $1\n      AND i.relname NOT IN (\n        SELECT constraint_name\n        FROM information_schema.table_constraints\n        WHERE table_name = $1\n        AND constraint_type IN ('PRIMARY KEY', 'UNIQUE')\n      )\n      GROUP BY i.relname, ix.indisunique\n    ",[n]);t[n].indexes=c.rows}return t}function D(e,t=!0){const n=Reflect.getMetadata("table:name",e),o=I(e),a=Reflect.getMetadata("foreign_keys",e)||{},r=Reflect.getMetadata("vector_columns",e)||{};let i=`CREATE TABLE ${T(n)} (\n`;const s=[],c=[];for(const[e,t]of Object.entries(o)){const n=t,o=n.name;if(n.isVector)continue;let a=`  ${T(o)} ${n.type}`;if(n.primary&&c.push(o),n.nullable||(a+=" NOT NULL"),n.unique&&(a+=" UNIQUE"),n.default){const t=n.default();if("jsonb"===n.type&&t.startsWith("ARRAY["))if("promptTypes"===e)a+=' DEFAULT \'["reflection", "questions", "encouragement"]\'::jsonb';else if("preferredTags"===e||"excludedTags"===e)a+=" DEFAULT '[]'::jsonb";else try{const e=t.substring(6,t.length-1);a+=` DEFAULT '["${e.split(",").map((e=>{const t=e.replace(/^'|'$/g,"").trim();return JSON.stringify(t).replace(/^"|"$/g,"")})).join('", "')}"]'::jsonb`}catch(e){console.error("Error parsing JSONB default value:",e),a+=" DEFAULT '[]'::jsonb"}else if("jsonb"===n.type)try{"string"==typeof t?t.endsWith("::jsonb")?a+=` DEFAULT '${t.replace(/::jsonb$/,"")}'::jsonb`:t.startsWith("{")||t.startsWith("[")?a+=` DEFAULT '${t}'::jsonb`:a+=` DEFAULT '${JSON.stringify(t)}'::jsonb`:a+=` DEFAULT '${JSON.stringify(t)}'::jsonb`}catch(e){console.error("Error parsing JSONB default value:",e),a+=" DEFAULT '{}'::jsonb"}else j(t)?a+=` DEFAULT ${t}`:a+=` DEFAULT ${S(t)}`}s.push(a)}if(c.length>0){const e=`  PRIMARY KEY (${c.map(T).join(", ")})`;s.push(e)}if(t)for(const[e,t]of Object.entries(a)){const a=t,r=o[e]?.name||e,i=`  CONSTRAINT ${T(`fk_${n}_${r}`)} FOREIGN KEY (${T(r)}) REFERENCES ${T(a.tableName)}(${T(a.columnName)})`;s.push(i)}i+=s.join(",\n"),i+="\n);\n";for(const[e,t]of Object.entries(r)){const a=o[e]?.name||e;i+=`ALTER TABLE ${T(n)} ADD COLUMN ${T(a)} vector(${t});\n`}return i}function I(e){const t={};let n=e;for(;n&&n.prototype;){const e=Reflect.getMetadata("columns",n)||{};for(const[n,o]of Object.entries(e))t[n]||(t[n]=o);n=Object.getPrototypeOf(n)}return t}function U(e,t){const n=Reflect.getMetadata("table:name",e),o=I(e),a=Reflect.getMetadata("foreign_keys",e)||{},r=Reflect.getMetadata("vector_columns",e)||{};let i="";for(const[e,a]of Object.entries(o)){const e=a,o=e.name;if(e.isVector)continue;const r=t.columns.find((e=>e.column_name===o));if(r){const t=[];e.nullable||"YES"!==r.is_nullable?e.nullable&&"NO"===r.is_nullable&&t.push(`ALTER COLUMN ${T(o)} DROP NOT NULL`):t.push(`ALTER COLUMN ${T(o)} SET NOT NULL`),e.type.toLowerCase()!==r.data_type.toLowerCase()&&t.push(`ALTER COLUMN ${T(o)} TYPE ${e.type} USING ${T(o)}::${e.type}`),t.length>0&&(i+=`ALTER TABLE ${T(n)} ${t.join(", ")};\n`)}else{let t=`${T(o)} ${e.type}`;if(e.nullable||(t+=" NOT NULL"),e.unique&&(t+=" UNIQUE"),e.default){const n=e.default();j(n)?t+=` DEFAULT ${n}`:t+=` DEFAULT ${S(n)}`}i+=`ALTER TABLE ${T(n)} ADD COLUMN ${t};\n`}}for(const[e,r]of Object.entries(a)){const a=r,s=o[e]?.name||e;t.foreignKeys.find((e=>e.column_name===s&&e.foreign_table_name===a.tableName&&e.foreign_column_name===a.columnName))||(i+=`ALTER TABLE ${T(n)} ADD CONSTRAINT ${T(`fk_${n}_${s}`)} FOREIGN KEY (${T(s)}) REFERENCES ${T(a.tableName)}(${T(a.columnName)});\n`)}for(const[e,a]of Object.entries(r)){const r=o[e]?.name||e;t.columns.find((e=>e.column_name===r))||(i+=`ALTER TABLE ${T(n)} ADD COLUMN ${T(r)} vector(${a});\n`)}return i}function q(e,t){const n=Reflect.getMetadata("table:name",e),o=I(e),a=Reflect.getMetadata("foreign_keys",e)||{};let r="";for(const[e,i]of Object.entries(a)){const a=i,s=o[e]?.name||e,c=`fk_${n}_${s}`,l=t[n];l&&l.foreignKeys&&l.foreignKeys.some((e=>e.column_name===s&&e.foreign_table_name===a.tableName&&e.foreign_column_name===a.columnName))||(r+=`ALTER TABLE ${T(n)} ADD CONSTRAINT ${T(c)} FOREIGN KEY (${T(s)}) REFERENCES ${T(a.tableName)}(${T(a.columnName)}) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;\n`)}return r}function F(e,t){let n="";n+="CREATE EXTENSION IF NOT EXISTS vector;\n\n",n+="-- First pass: Create all tables without foreign keys\n";for(const o of e){const e=Reflect.getMetadata("table:name",o);if(t[e]){const a=U(o,t[e]);a&&(n+=`-- Altering table ${e}\n${a}\n`)}else n+=`-- Creating table ${e}\n${D(o,!1)}\n`}n+="\n-- Second pass: Add foreign key constraints\n";for(const o of e){const e=Reflect.getMetadata("table:name",o),a=Reflect.getMetadata("foreign_keys",o)||{};Object.keys(a).length>0&&(n+=`-- Adding foreign keys to ${e}\n${q(o,t)}\n`)}return n}function v(e,t){const n=Reflect.getMetadata("design:type",e,t);if(!n)return"text";switch(n.name){case"String":default:return"text";case"Number":return"double precision";case"Boolean":return"boolean";case"Date":return"timestamp with time zone";case"Array":case"Object":return"jsonb"}}function x(e,t){try{const n=(new e.constructor)[t];if(null==n)return t.toLowerCase().includes("date")||t.toLowerCase().includes("time")?"timestamp with time zone":t.toLowerCase().includes("price")||t.toLowerCase().includes("amount")||t.toLowerCase().includes("number")?"double precision":t.toLowerCase().includes("is")||t.toLowerCase().includes("has")||t.toLowerCase().includes("enable")||t.toLowerCase().includes("disable")?"boolean":"text";if("string"==typeof n)return"text";if("number"==typeof n)return"double precision";if("boolean"==typeof n)return"boolean";if(n instanceof Date)return"timestamp with time zone";if(Array.isArray(n))return"jsonb";if("object"==typeof n)return"jsonb"}catch(e){return null}return null}try{require("ts-node").register({project:"tsconfig.node.json",transpileOnly:!0,compilerOptions:{module:"CommonJS"}})}catch(e){console.log("ts-node not available, assuming TypeScript is already compiled")}async function k(e=!1){process.env.DATABASE_URL||(console.error("DATABASE_URL environment variable is not set"),process.exit(1));const n=new t({connectionString:process.env.DATABASE_URL});try{const t=await n.connect();try{e||await t.query("BEGIN"),e?console.log("Vector extension would be installed (dry run)"):await async function(e){try{await e.query("CREATE EXTENSION IF NOT EXISTS vector;"),console.log("Vector extension is installed or already exists.")}catch(e){throw console.error("Error ensuring vector extension:",e),e}}(n);const o=await C();console.log(`Loaded ${o.length} entity classes`);const a=await M(n);console.log(`Retrieved current schema with ${Object.keys(a).length} tables`);const r=F(o,a);"CREATE EXTENSION IF NOT EXISTS vector;"===r.trim()?console.log("No schema changes needed, database is up to date"):e?(console.log("DRY RUN: The following SQL would be executed:"),console.log(r),console.log("No changes were made to the database (dry run)")):(console.log("Executing migration SQL:"),console.log(r),await t.query(r),await t.query("COMMIT"),console.log("Migration completed")),e||await t.query("COMMIT")}catch(n){e||await t.query("ROLLBACK"),console.error("Migration failed:",n),process.exit(1)}finally{t.release()}}catch(e){console.error("Unhandled error during migration:",e),process.exit(1)}finally{await n.end()}}r.config(),require.main===module&&k().catch((e=>{console.error("Unhandled error during migration:",e),process.exit(1)}));export{u as Column,f as ForeignKey,l as Table,m as VectorColumn,h as deleteBy,E as ensureVectorDimensions,S as escapeSqlString,A as findBy,p as findSimilarEntries,y as formatVector,U as generateAlterTableSQL,F as generateMigrationSQL,D as generateTableSQL,M as getCurrentSchema,v as inferType,x as inferTypeFromValue,j as isSqlFunction,w as listAll,C as loadEntityClasses,d as pool,g as processVectorEmbeddings,_ as query,T as quoteIdentifier,k as runMigration,$ as save,b as storeEmbedding,L as withSavepoint,O as withTransaction};
//# sourceMappingURL=index.esm.js.map
